\subsection{Implementation of the Data Management}
\label{subsec:datamanagement}

\fixme{hvis der er tid så beskriv HTTPhelper på kode niveau}

\paragraph{Server}
As mentioned in \ref{subsubsec:server}, \texttt{ServiceHelper} provides an easy to use interface for the application. To clarify the entire process of communicating with the server, consider \ref{lst:getfavorites}. This example is all the code needed from the \texttt{Activity} perspective. The \texttt{ServiceHelper} is used to get "favorised recipes by account id" and returns a list of recipes when finished.

\begin{lstlisting}[language=java, label={lst:getfavorites}, caption={Sending a server request from an Activity}]
Recipes = ServiceHelper.GetFavorisedRecipesByAccountId(AccountId);
\end{lstlisting}

The process of \texttt{GetFavorisedRecipesByAccountId} can be seen in \ref{lst:servicehelper}. The method provides the specifics on how to create the request properly - an account id is required, and the request should be sent to a specific address (Line 4). Furthermore it is a \texttt{Get} request.
In this case there is nothing that needs JSON serialization. The server response is however put through the \texttt{JSONHelper} and parsed into a readable format - Namely a list using the model called \texttt{Recipe}. The threading is still not visible because it is done within the \texttt{HTTPHelper}.

\begin{lstlisting}[language=java, label={lst:servicehelper}, caption={GetFavorisedRecipesByAccountId from ServiceHelper}]
public static ArrayList<Recipe> GetFavorisedRecipesByAccountId(int accountId){
    String response = null;
    try {
        response = HTTPHelper.HTTPGet("http://" + ip + ":8000/RestService/Favorises/GetFavorisedRecipesByAccountId?accountId=" + accountId);
        System.out.println(response);
    } catch (Exception e) {
        e.printStackTrace();
    }
    ArrayList<Recipe> recipes = JSONHelper.DeserializeList(response, Recipe.class);
    return recipes;
}
\end{lstlisting}