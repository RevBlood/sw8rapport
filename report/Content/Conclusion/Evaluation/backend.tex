\subsection{Backend}
\label{subsec:evalbackend}
\paragraph{RESTful Web Service}
The web service performs very well and fulfills the purpose it was designed for. It offers a total of 46 HTTP requests to the client and completely hides away complex database functionality, as well as return useful computational results for the client like the results from the recommendation system. 

The web service is well structured and has been split into self-documenting interfaces responsible for very separated parts of the backend. Following this strict name-convention, it should be clear for the developer using the web service what a specific request should return. If something goes wrong, they are provided with a informative error-message, as can be seen in section \ref{chap:test} regarding test. 

In this project the web service does not fully receive the recognition it deserves. This is due to the uniform interface is provides, which is completely platform independent, meaning that this backend could serve iOS, windows phone or in this case android applications without alterations. This goal was part of the initial design decisions for the RESTful web service, because we wanted to develop a long-term realistic solution instead of hard-coding Android-specific responses based on an ad-hoc developed interface. This was not attractive for this project and complements the creation of the web service.

One of the only downsides to the RESTful web service is the lack of performance testing. We designed the backend with a purpose for fast query-handling and wanted to decrease the time a user spends waiting for results in the application. We never reached a goal with the data management that allowed us to proceed into this type of testing. The amount of data stored would simply not reflect the correct query time and the response-time through the web service would not be realistically used to say anything about the performance measures.

\paragraph{Data Management}
This project is highly dependent on the use of good and valid data. The data management has been prioritized very important which is why so many resources has been spent making the right decisions with the database. We wanted to avoid having to redesign the database because so much other functionality relies on it and is built on top of it. The RESTful web service HTTP requests are functioning purely as gateway to the database, and database changes cascades through the entire backend and requires extensive alterations, also to the web service. 

We coded an approximately 700 line long \texttt{DBController}, which handles all the desired database queries in this project. Had this project continued, we would spend time looking upon these queries and performance-optimizing them to deliver the fastest results possible to the user. Due to the limited resources in this project, we decided to lay aside the optimization until we had realistic data and application usage to work with. 

We only had to make two minor adjustments to the initial database design in this project. Because we spent so many resources designing it, we were able to keep the number of adjustments this low. The first adjustment we had to make was removing tags from recipes and ingredients themselves and making this as a weak-entity type, allowing easier and faster querying using tags. The second adjustment was an update to the attributes on ingredients. We added three additional attributes called organic, fat, and fresh. Since we started working with the offers from eTilbudsavis\cite{etilbudsavis}, we found that adding these attributes would make querying for healthy or fresh food much easier. Therefore we implemented this update.

\paragraph{Completeness}
The backend as a data provider is fully functional, and it is easily possible to access the data through the web service. The problem with the backend is  getting the valuable data from the external sources, parsing the data correctly and storing in the database for the user to look at and use. This is the biggest downside to the backend in its current state.