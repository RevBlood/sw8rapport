\chapter{Test}
\label{chap:test}

The application is futile without a connection to the backend. This is what allows the user to login and afterwards send data for the user to look at and work with. It is crucial for the application that the data can be retrieved and that the data corresponds to the executed HTTP request and is returned in the right format. Additionally, the developer working with the API should be able to identify what happened to a failing HTTP requests. Based on these arguments, we decided to perform functional testing on our backend, from a perspective seen as the developer using the API. 

We decided to do a variation of functional testing. We are not working with a customer and cannot perform testing based on customer specifications or customer design-documents. Instead we test for correct functionality in a sub-part of the whole system. In ones case it means accessing an exposed web service HTTP request, that will retrieve data from the database, serialize it to JSON format and return it to the client. In another case this means accessing an exposed web service HTTP request that will receive a JSON formatted object, store it in the database and return whether it was stored successfully or not.

To perform the functional testing we use a tool called \textit{Fiddler Web Debugger}. It is a free web debugging proxy for any browser, system or platform\cite{fiddler}. Fiddler provides a feature to compose HTTP requests, and a GUI to look at the status of the requests as well as the response message. 

Once we determine what we want to test, we structure the test in three simple steps.
\begin{itemize}
\item Create input data
\item Determine output data
\item Compare the result with the desired output data
\end{itemize}

We performed this test on all 46 web service HTTP requests exposed through our RESTful API. This would be extensive to read through, so we decided to describe one request and how it was tested, as well as a second request that shows an interesting error that we had to correct. We will show the test for the AddAccount POST-request, and the GetRecipeById GET-request.

\subsection{AddAccount}
\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{Pictures/test/composeraddaccount.png}
\caption{AddAccount}
\label{fig:composeraddaccount}
\end{figure}

\begin{figure}
	\centering
	% 1
	\begin{subfigure}[b]{\textwidth}
		\includegraphics[width=\textwidth]{Pictures/test/AddAccountOK.png}
		\caption{OK}
		\label{fig:AddAccountOK}
	\end{subfigure}
	% 2
	\begin{subfigure}[b]{\textwidth}
		\includegraphics[width=\textwidth]{Pictures/test/AddAccountduplicate.png}
		\caption{Duplicate Key}
		\label{fig:AddAccountduplicate}
	\end{subfigure}
	% 3
	\begin{subfigure}[b]{\textwidth}
		\includegraphics[width=\textwidth]{Pictures/test/AddAccountbadrequest.png}
		\caption{Bad Request}
		\label{fig:AddAccountbadrequest}
	\end{subfigure}
	% 4
	\begin{subfigure}[b]{\textwidth}
		\includegraphics[width=\textwidth]{Pictures/test/AddAccountmethodnotallowed.png}
		\caption{Method Not Allowed}
		\label{fig:AddAccountmethodnotallowed}
	\end{subfigure}
	% 5
	\begin{subfigure}[b]{\textwidth}
		\includegraphics[width=\textwidth]{Pictures/test/AddAccountconnectionfailed.png}
		\caption{Connection Failed}
		\label{fig:AddAccountconnectionfailed}
	\end{subfigure}
	\caption{Results gathered from testing AddAccount}
	\label{fig:addaccountresults}
\end{figure}

\paragraph{OK}
In this case, the desired functionality is for the backend to insert a new row in the database-table called accounts, with the content specified in JSON-format listed in the composer figure \ref{fig:composeraddaccount}. 

For the given response-message, see figure \ref{fig:AddAccountOK}, this is indeed the desired result and the test-case succeeded.
\paragraph{Duplicate Key}
In this case, the desired functionality is for the backend to detect that there already exist a row in the database with  the same data as the one entered in the composer figure \ref{fig:composeraddaccount}. This will for an account only be possible for attributes marked with the UNIQUE identifier. In this case, it can only be the \texttt{email}, because the \texttt{accountid} is assigned by the database itself. This error was generated by executing the exact same HTTP request which has just returned an HTTP header with the OK result.

For the database violations, multiple types of database error-messages can occur, allowing for easy detection of the error made by the developer.

For the given response-message, see figure \ref{fig:AddAccountduplicate}, this is indeed the desired result and the test-case succeeded.
\paragraph{Bad Request}
In this case, the desired functionality is for the backend to tell the developer that they entered a bad request. This error can be generated in two ways. The first can be generated by corrupting the JSON formatting. This mean you do not following the standard for JSON-formatting and the backend detects this. The second error can be generated by changing the application/json in the composer figure \ref{fig:composeraddaccount} to application/xml. This means that the request body must be formatted as xml, which it obviously is not, hereby the error.

For the given response-message, see figure \ref{fig:AddAccountbadrequest}, this is indeed the desired result and the test-case succeeded.
\paragraph{Method Not Allowed}
The Web Service defined the type of \texttt{AddAccount} to be POST. Defining the HTTP requests to be any other type will result in the Method Not Allowed error. This error can be generated by changing the method-type to any other type than POST.

For the given response-message, see figure \ref{fig:AddAccountmethodnotallowed}, this is indeed the desired result and the test-case succeeded.
\paragraph{Connection Failed}
We turned the API off and executed an HTTP request trying to access the API. This should result in the connection failed error. 

For the given response-message, see figure \ref{fig:AddAccountconnectionfailed}, this is indeed the desired result and the test-case succeeded.

\subsection{GetRecipeById}
This request returns a targeted recipe from the database, given that the provided id exist in the database. During the early stages of the web service implementation, we had a strange error occur on the client side running Java. The code kept throwing a java.net.SocketException: ECONNRESET (Connection reset by peer)\cite{socketexception}. The exception basically says that the connection was terminated by the host, without returning an answer. This was strange because the web service was suppose to return a recipe if the id existed or respond with HTTP status code 204 No Content, if it did not exist. The error occurred because the web service did not properly get told by the \texttt{DBController} that it did not find a recipe with the provided id, and when the web service stood without a recipe to return as well as no confirmation that no such recipe existed, it just terminated the connection to the client. We fixed the error by alternating the way the \texttt{DBController} handles empty queries, and it will now properly inform the client with 204 No Content.


